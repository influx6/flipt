{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flipt A self contained feature flag solution. What is Flipt Flipt is an open source, self contained application that enables you to use feature flags and experiment (A/B test) across services, running in your environment. This means that you can deploy Flipt within your existing infrastructure and not have to worry about your information being sent to a third party, or the latency required to communicate across the internet. Flipt includes native client SDKs as well as a REST API so you can choose how to best integrate Flipt with your applications. For more on Flipt and it's concepts, take a look at the Concepts documentation. Flipt Features Flipt enables you to add feature flag support to your existing applications, with a simple, single UI and API. This can range from simple on/off feature flags to more advanced use cases where you want to be able to rollout different versions of a feature to percentages of your users. Flipt features include: Fast. Written in Go. Optimized for performance Stand alone, easy to run server with no external dependencies Native GRPC client SDKs to integrate with your applications Simple REST API Modern UI and debug console Why Flipt Many organizations understand the benefit of using feature flags in production, so they choose to implement them themselves in their main application or monolith. As their organization grows, so does their application/infrastructure and functionality makes it's way into a multitude of other services. Many times those services aren't even implemented in the same language. This is where their original feature flag solution tends to break down as it cannot be easily adapted to those services or languages. This results in: Only being able to use feature flags in a subset of services. Having multiple sources of truth for feature flags depending on the service/implementation leading to unpredictability. Flipt solves all of these issues and more and enables you to focus on your applications, without having to worry about implementing your own feature flag solution that works across your infrastructure. On top of this, Flipt provides a nice, modern UI so that you can always monitor the state of your feature flags and experiments in a single place. Running Flipt Flipt is a single, self contained binary that you run on your own servers or cloud infrastructure. There are a multitude of benefits to running Flipt yourself, including: Security . No Flipt data leaves your servers and you don't have to open your systems to the outside world to communicate with Flipt. It all runs within your existing infrastructure. Speed . Since Flipt is co-located with your existing services, you do not have to communicate across the internet to another application running on the other side of the world which can add excessive latency and slow down your applications. Simplicity . Flipt is a single binary with no external dependencies. This means there is no database to manage or connect to, no clusters to configure, and data backup is as simple as copying a single file. What's Next Want to get up and running with Flipt? See the Getting Started section. For a more detailed guide on how to setup and run Flipt, checkout the Installation documentation. For more information on how Flipt works behind the scenes, read the Architecture documentation. To learn how to integrate Flipt with your existing applications, see the Integration guide. Documentation https://markphelps.github.io/flipt Author Mark Phelps, @mark_a_phelps , mark.aaron.phelps at gmail.com","title":"Flipt"},{"location":"#flipt","text":"A self contained feature flag solution.","title":"Flipt"},{"location":"#what-is-flipt","text":"Flipt is an open source, self contained application that enables you to use feature flags and experiment (A/B test) across services, running in your environment. This means that you can deploy Flipt within your existing infrastructure and not have to worry about your information being sent to a third party, or the latency required to communicate across the internet. Flipt includes native client SDKs as well as a REST API so you can choose how to best integrate Flipt with your applications. For more on Flipt and it's concepts, take a look at the Concepts documentation.","title":"What is Flipt"},{"location":"#flipt-features","text":"Flipt enables you to add feature flag support to your existing applications, with a simple, single UI and API. This can range from simple on/off feature flags to more advanced use cases where you want to be able to rollout different versions of a feature to percentages of your users. Flipt features include: Fast. Written in Go. Optimized for performance Stand alone, easy to run server with no external dependencies Native GRPC client SDKs to integrate with your applications Simple REST API Modern UI and debug console","title":"Flipt Features"},{"location":"#why-flipt","text":"Many organizations understand the benefit of using feature flags in production, so they choose to implement them themselves in their main application or monolith. As their organization grows, so does their application/infrastructure and functionality makes it's way into a multitude of other services. Many times those services aren't even implemented in the same language. This is where their original feature flag solution tends to break down as it cannot be easily adapted to those services or languages. This results in: Only being able to use feature flags in a subset of services. Having multiple sources of truth for feature flags depending on the service/implementation leading to unpredictability. Flipt solves all of these issues and more and enables you to focus on your applications, without having to worry about implementing your own feature flag solution that works across your infrastructure. On top of this, Flipt provides a nice, modern UI so that you can always monitor the state of your feature flags and experiments in a single place.","title":"Why Flipt"},{"location":"#running-flipt","text":"Flipt is a single, self contained binary that you run on your own servers or cloud infrastructure. There are a multitude of benefits to running Flipt yourself, including: Security . No Flipt data leaves your servers and you don't have to open your systems to the outside world to communicate with Flipt. It all runs within your existing infrastructure. Speed . Since Flipt is co-located with your existing services, you do not have to communicate across the internet to another application running on the other side of the world which can add excessive latency and slow down your applications. Simplicity . Flipt is a single binary with no external dependencies. This means there is no database to manage or connect to, no clusters to configure, and data backup is as simple as copying a single file.","title":"Running Flipt"},{"location":"#whats-next","text":"Want to get up and running with Flipt? See the Getting Started section. For a more detailed guide on how to setup and run Flipt, checkout the Installation documentation. For more information on how Flipt works behind the scenes, read the Architecture documentation. To learn how to integrate Flipt with your existing applications, see the Integration guide.","title":"What's Next"},{"location":"#documentation","text":"https://markphelps.github.io/flipt","title":"Documentation"},{"location":"#author","text":"Mark Phelps, @mark_a_phelps , mark.aaron.phelps at gmail.com","title":"Author"},{"location":"architecture/","text":"Architecture The overall Flipt server architecture is shown in this diagram: Note Arrows indicate request or connection initiation direction, not necessarily dataflow direction. As shown in the above diagram, the Flipt application is made up of three main components: Flipt Backend Service Flipt REST API Flipt Web UI All three of these components run side by side in a single binary. The UI and REST API are served on the same port ( 8080 by default) and the Backend Service is served on 9000 by default. Backend Service The Flipt Backend Service is the main entrypoint to the application and implements all of the business logic for Flipt. This is what users of the gRPC client SDKs will communicate with, allowing for fast, efficient communication with your applications. REST API The Flipt REST API is implemented on top of the Backend Service using gRPC Gateway (described below). The REST API is served under /api/v1 and allows all actions that the client SDKs allow. Web UI The Flipt Web UI is a modern, minimalist UI to allow you to easily setup and monitor your feature flags and experiments. It's served as a JavaScript Single Page Application (SPA) and communicates with the Flipt Backend Service through the REST API. A guide to using the UI for the first time can be found in the Getting Started documentation. Technologies Flipt is built using several amazing open source technologies including: Go Programming Language gRPC gRPC Gateway SQLite Vue.js Bulma Buefy A brief description of why each technology was chosen is below. Go From the Go documentation: Go makes it easy to build simple, reliable and efficient software. These are all goals that Flipt also aspires to. Flipt was written in Go mainly because of it's ability to produce bulletproof systems software as as single binary for multiple architectures. This allows Flipt to easily be deployed in almost any environment since it's as simple as copying a compiled binary. GRPC gRPC is a high performance, open source RPC framework created by Google. gRPC allows Flipt to be performant by eliminating much of the overhead incurred by using standard HTTP for communication. gRPC also has the benefit of being able to generate client SDKs in many different languages from a single Protobuf file. This allows you easily integrate your services with Flipt regardless of the language they are written in. GRPC Gateway While awesome, gRPC might not be for everyone. gRPC Gateway is a reverse-proxy server which translates a RESTful JSON API into gRPC. This allows Flipt to implement a REST API as well as the gRPC API described above. This means that the REST API follows the same codepaths as the gRPC service that Flipt implements, allowing for reduced bugs and a simpler architecture. The Flipt UI is also built on top of the REST API provided by gRPC gateway. SQLite From the SQLite documentation: SQLite is a C-language library that implements a small, fast, self-contained, high-reliability, full-featured, SQL database engine. SQLite is the most used database engine in the world. Two of the major goals of Flipt are to be 1) Fast and 2) Self contained. SQLite allows us to accomplish both. By embedding the datastore 'within' the application, we eliminate the need to communicate to an external database. This results in faster performance with is required if putting calls to Flipt in the 'hotpath' of your applications. Using SQLite means that you do not need to run an additional client/server RDBMS such as Postgres or MySQL in order for Flipt to store and retrieve your data. This means it's easy to get up and running with Flipt without having to install any additional software. And since a SQLite database is just a file, you can easily backup your data using traditional file backup methods. Vue.js Vue.js is a minimal, modern and performant JavaScript framework that makes it easy to implement reactive frontend applications such as the Flipt UI. Vue.js was chosen because of it's rich ecosystem as well as ease of use to get started. The Flipt UI is a Single Page Application (SPA) written in JavaScript using Vue.js, that communicates with with the Flipt backend over the Flipt REST API. This means that the UI uses the same API that end clients do, meaning that anything you can do with the Flipt API, you can do in the UI and vice versa. Bulma Bulma is a free, open source CSS framework based on Flexbox. It makes it easy to make nice looking user interfaces with minimal CSS. Buefy Buefy creates lightweight UI components for Vue.js based on Bulma. The Flipt UI was built using several Buefy components that greatly enhanced the speed of development.","title":"Architecture"},{"location":"architecture/#architecture","text":"The overall Flipt server architecture is shown in this diagram: Note Arrows indicate request or connection initiation direction, not necessarily dataflow direction. As shown in the above diagram, the Flipt application is made up of three main components: Flipt Backend Service Flipt REST API Flipt Web UI All three of these components run side by side in a single binary. The UI and REST API are served on the same port ( 8080 by default) and the Backend Service is served on 9000 by default.","title":"Architecture"},{"location":"architecture/#backend-service","text":"The Flipt Backend Service is the main entrypoint to the application and implements all of the business logic for Flipt. This is what users of the gRPC client SDKs will communicate with, allowing for fast, efficient communication with your applications.","title":"Backend Service"},{"location":"architecture/#rest-api","text":"The Flipt REST API is implemented on top of the Backend Service using gRPC Gateway (described below). The REST API is served under /api/v1 and allows all actions that the client SDKs allow.","title":"REST API"},{"location":"architecture/#web-ui","text":"The Flipt Web UI is a modern, minimalist UI to allow you to easily setup and monitor your feature flags and experiments. It's served as a JavaScript Single Page Application (SPA) and communicates with the Flipt Backend Service through the REST API. A guide to using the UI for the first time can be found in the Getting Started documentation.","title":"Web UI"},{"location":"architecture/#technologies","text":"Flipt is built using several amazing open source technologies including: Go Programming Language gRPC gRPC Gateway SQLite Vue.js Bulma Buefy A brief description of why each technology was chosen is below.","title":"Technologies"},{"location":"architecture/#go","text":"From the Go documentation: Go makes it easy to build simple, reliable and efficient software. These are all goals that Flipt also aspires to. Flipt was written in Go mainly because of it's ability to produce bulletproof systems software as as single binary for multiple architectures. This allows Flipt to easily be deployed in almost any environment since it's as simple as copying a compiled binary.","title":"Go"},{"location":"architecture/#grpc","text":"gRPC is a high performance, open source RPC framework created by Google. gRPC allows Flipt to be performant by eliminating much of the overhead incurred by using standard HTTP for communication. gRPC also has the benefit of being able to generate client SDKs in many different languages from a single Protobuf file. This allows you easily integrate your services with Flipt regardless of the language they are written in.","title":"GRPC"},{"location":"architecture/#grpc-gateway","text":"While awesome, gRPC might not be for everyone. gRPC Gateway is a reverse-proxy server which translates a RESTful JSON API into gRPC. This allows Flipt to implement a REST API as well as the gRPC API described above. This means that the REST API follows the same codepaths as the gRPC service that Flipt implements, allowing for reduced bugs and a simpler architecture. The Flipt UI is also built on top of the REST API provided by gRPC gateway.","title":"GRPC Gateway"},{"location":"architecture/#sqlite","text":"From the SQLite documentation: SQLite is a C-language library that implements a small, fast, self-contained, high-reliability, full-featured, SQL database engine. SQLite is the most used database engine in the world. Two of the major goals of Flipt are to be 1) Fast and 2) Self contained. SQLite allows us to accomplish both. By embedding the datastore 'within' the application, we eliminate the need to communicate to an external database. This results in faster performance with is required if putting calls to Flipt in the 'hotpath' of your applications. Using SQLite means that you do not need to run an additional client/server RDBMS such as Postgres or MySQL in order for Flipt to store and retrieve your data. This means it's easy to get up and running with Flipt without having to install any additional software. And since a SQLite database is just a file, you can easily backup your data using traditional file backup methods.","title":"SQLite"},{"location":"architecture/#vuejs","text":"Vue.js is a minimal, modern and performant JavaScript framework that makes it easy to implement reactive frontend applications such as the Flipt UI. Vue.js was chosen because of it's rich ecosystem as well as ease of use to get started. The Flipt UI is a Single Page Application (SPA) written in JavaScript using Vue.js, that communicates with with the Flipt backend over the Flipt REST API. This means that the UI uses the same API that end clients do, meaning that anything you can do with the Flipt API, you can do in the UI and vice versa.","title":"Vue.js"},{"location":"architecture/#bulma","text":"Bulma is a free, open source CSS framework based on Flexbox. It makes it easy to make nice looking user interfaces with minimal CSS.","title":"Bulma"},{"location":"architecture/#buefy","text":"Buefy creates lightweight UI components for Vue.js based on Bulma. The Flipt UI was built using several Buefy components that greatly enhanced the speed of development.","title":"Buefy"},{"location":"concepts/","text":"Concepts This document describes the basic concepts of Flipt. More information on how to use Flipt is noted in the Getting Started documentation. Flags Flags are the basic unit in the Flipt ecosystem. Flags represent experiments or features that you want to be able to enable or disable for users of your applications. For example, a flag named new-contact-page , could be used to determine whether or not a given user sees the latest version of a contact us page that you are working on when they visit your homepage. Flags can be used as simple on/off toggles or with variants and rules to support more elaborate usecases. Variants Variants are options for flags. For example, if you have a flag colorscheme that determines which main colors your users see when they log in to your application, then possible variants could be include blue , green or red . Segments Segments allow you to split your userbase or audience up into predefined slices. This is a powerful feature that enables targeting groups to determine if a flag or variant applies to them. An example segment could be new-users . Tip Segments are global across the Flipt application, so they can be used with multiple flags. Constraints Constraints allow you to determine which segment a given entity is a part of. For example, for a user to fall into the above new-users segment, you may want to check their finished_onboarding property. All constraints have a property , type , operator and optionally a value . property the context key to match against, see the context section below type one of the basic types: string, number or boolean operator how to compare the property against the value value (optional) what to compare with the operator Note In order for a segment to match, it must match ALL of it's constraints. Rules Rules allow you to tie your flags, variants and segments together by specifying which segments are targeted by which variants. Rules can be as simple as IF IN segment THEN RETURN variant_a or they can be more rich by using distribution logic to rollout features on a percent basis. Continuing our previous example, we may want to return the flag variant blue for all entities in the new-users segment. This would be configured like so: Note As shown, rules are evaluated in order per their rank from 1-N. The first rule that matches wins. Once created, rules can be re-ordered to change how they are evaluated. Distributions Distributions allow you to rollout different variants of your flag to percentages of your userbase based on your rules. Let's say that instead of always showing the blue variant to your new-users segment, you want to show blue to 30% of new-users , red to 10%, and green to the remaining 60%. You would accomplish this using rules with distributions: This is an extremely powerful feature of Flipt that can help you seamlessly deploy new features of your applications to your users while also limiting reach of potential bugs. Evaluation Evaluation is the process of sending requests to the Flipt server to process and determine if that request matches any of your segments, and if so which variant to return. In the above example involving colors, evaluation is where you send information about your current user to determine if they are a new-user , and which color ( blue , red , or green ) that they should see for their main colorscheme. Entities Evaluation works by uniquely identifying each thing that you want to compare against your segments and flags. We call this an entity in the Flipt ecosystem. More often than not this will be a user, but we didn't want to make any assumptions on how your application works, which is why entity was chosen. entity what you want to test against in your application For Flipt to successfully determine which bucket your entities fall into, it must have a way to uniquely identify them. This is the entityId and it is a simple string. It's up to you what that entityId is. It could be a: email address userID ip address physical address etc Anything that is unique enough for your application and it's requirements. Context The final piece of the puzzle is context. Context allows Flipt to determine which segment your entity falls into by comparing it to all of the possible constraints that you defined. context metadata associated with your entity, used to determine which if any segments that entity is a member of Examples of context could include: isAdmin favoriteColor country freeUser Think of these as pieces of information that are usually not unique, but that can be used to split your entities into your segments. You can include as much or as little context for each entity as you want, however the more context that you provide, the more likely it is that a entity will match one of your segments. In Flipt, context is a simple map of key-value pairs where the key is the property to match against all constraints, and the value is what is compared.","title":"Concepts"},{"location":"concepts/#concepts","text":"This document describes the basic concepts of Flipt. More information on how to use Flipt is noted in the Getting Started documentation.","title":"Concepts"},{"location":"concepts/#flags","text":"Flags are the basic unit in the Flipt ecosystem. Flags represent experiments or features that you want to be able to enable or disable for users of your applications. For example, a flag named new-contact-page , could be used to determine whether or not a given user sees the latest version of a contact us page that you are working on when they visit your homepage. Flags can be used as simple on/off toggles or with variants and rules to support more elaborate usecases.","title":"Flags"},{"location":"concepts/#variants","text":"Variants are options for flags. For example, if you have a flag colorscheme that determines which main colors your users see when they log in to your application, then possible variants could be include blue , green or red .","title":"Variants"},{"location":"concepts/#segments","text":"Segments allow you to split your userbase or audience up into predefined slices. This is a powerful feature that enables targeting groups to determine if a flag or variant applies to them. An example segment could be new-users . Tip Segments are global across the Flipt application, so they can be used with multiple flags.","title":"Segments"},{"location":"concepts/#constraints","text":"Constraints allow you to determine which segment a given entity is a part of. For example, for a user to fall into the above new-users segment, you may want to check their finished_onboarding property. All constraints have a property , type , operator and optionally a value . property the context key to match against, see the context section below type one of the basic types: string, number or boolean operator how to compare the property against the value value (optional) what to compare with the operator Note In order for a segment to match, it must match ALL of it's constraints.","title":"Constraints"},{"location":"concepts/#rules","text":"Rules allow you to tie your flags, variants and segments together by specifying which segments are targeted by which variants. Rules can be as simple as IF IN segment THEN RETURN variant_a or they can be more rich by using distribution logic to rollout features on a percent basis. Continuing our previous example, we may want to return the flag variant blue for all entities in the new-users segment. This would be configured like so: Note As shown, rules are evaluated in order per their rank from 1-N. The first rule that matches wins. Once created, rules can be re-ordered to change how they are evaluated.","title":"Rules"},{"location":"concepts/#distributions","text":"Distributions allow you to rollout different variants of your flag to percentages of your userbase based on your rules. Let's say that instead of always showing the blue variant to your new-users segment, you want to show blue to 30% of new-users , red to 10%, and green to the remaining 60%. You would accomplish this using rules with distributions: This is an extremely powerful feature of Flipt that can help you seamlessly deploy new features of your applications to your users while also limiting reach of potential bugs.","title":"Distributions"},{"location":"concepts/#evaluation","text":"Evaluation is the process of sending requests to the Flipt server to process and determine if that request matches any of your segments, and if so which variant to return. In the above example involving colors, evaluation is where you send information about your current user to determine if they are a new-user , and which color ( blue , red , or green ) that they should see for their main colorscheme.","title":"Evaluation"},{"location":"concepts/#entities","text":"Evaluation works by uniquely identifying each thing that you want to compare against your segments and flags. We call this an entity in the Flipt ecosystem. More often than not this will be a user, but we didn't want to make any assumptions on how your application works, which is why entity was chosen. entity what you want to test against in your application For Flipt to successfully determine which bucket your entities fall into, it must have a way to uniquely identify them. This is the entityId and it is a simple string. It's up to you what that entityId is. It could be a: email address userID ip address physical address etc Anything that is unique enough for your application and it's requirements.","title":"Entities"},{"location":"concepts/#context","text":"The final piece of the puzzle is context. Context allows Flipt to determine which segment your entity falls into by comparing it to all of the possible constraints that you defined. context metadata associated with your entity, used to determine which if any segments that entity is a member of Examples of context could include: isAdmin favoriteColor country freeUser Think of these as pieces of information that are usually not unique, but that can be used to split your entities into your segments. You can include as much or as little context for each entity as you want, however the more context that you provide, the more likely it is that a entity will match one of your segments. In Flipt, context is a simple map of key-value pairs where the key is the property to match against all constraints, and the value is what is compared.","title":"Context"},{"location":"configuration/","text":"Configuration There are two ways to configure Flipt: using a configuration file or through environment variables. Configuration File The default way that Flipt is configured is with the use of a configuration file default.yml . This file is read when Flipt starts up and configures several important properties for the backend and API. You can edit any of these properties to your liking, and on restart Flipt will pick up the new changes. Note These defaults are commented out in default.yml to give you an idea of what they are. To change them you'll first need to uncomment the property. These properties are as follows: Property Description Default host The IP on which to serve the Flipt application 0.0.0.0 log.level Level at which messages are logged (trace, debug, info, warn, error, fatal, panic) info api.port The port on which to serve the Flipt REST API 8080 backend.port The port on which to serve the Flipt Backend server 9000 db.name The name given to the Flipt database (suffixed with .db) flipt db.path Where to store the Flipt database /var/opt/flipt db.migrations.auto If database migrations are run on Flipt startup true db.migrations.path Where the Flipt database migration files are kept /etc/flipt/config/migrations Using Environment Variables All options in the configuration file can be overridden using environment variables using the syntax: FLIPT_ SectionName _ KeyName Tip Using environment variables to override defaults is especially helpful when running with Docker as described in the Installation documentation. Everything should be upper case, . should be replaced by _ . For example, given these configuration settings: backend : port : 9000 db : name : flipt path : /var/opt/flipt You can override them using: export FLIPT_BACKEND_PORT = 9001 export FLIPT_DB_NAME = my-db export FLIPT_DB_PATH = /tmp/db","title":"Configuration"},{"location":"configuration/#configuration","text":"There are two ways to configure Flipt: using a configuration file or through environment variables.","title":"Configuration"},{"location":"configuration/#configuration-file","text":"The default way that Flipt is configured is with the use of a configuration file default.yml . This file is read when Flipt starts up and configures several important properties for the backend and API. You can edit any of these properties to your liking, and on restart Flipt will pick up the new changes. Note These defaults are commented out in default.yml to give you an idea of what they are. To change them you'll first need to uncomment the property. These properties are as follows: Property Description Default host The IP on which to serve the Flipt application 0.0.0.0 log.level Level at which messages are logged (trace, debug, info, warn, error, fatal, panic) info api.port The port on which to serve the Flipt REST API 8080 backend.port The port on which to serve the Flipt Backend server 9000 db.name The name given to the Flipt database (suffixed with .db) flipt db.path Where to store the Flipt database /var/opt/flipt db.migrations.auto If database migrations are run on Flipt startup true db.migrations.path Where the Flipt database migration files are kept /etc/flipt/config/migrations","title":"Configuration File"},{"location":"configuration/#using-environment-variables","text":"All options in the configuration file can be overridden using environment variables using the syntax: FLIPT_ SectionName _ KeyName Tip Using environment variables to override defaults is especially helpful when running with Docker as described in the Installation documentation. Everything should be upper case, . should be replaced by _ . For example, given these configuration settings: backend : port : 9000 db : name : flipt path : /var/opt/flipt You can override them using: export FLIPT_BACKEND_PORT = 9001 export FLIPT_DB_NAME = my-db export FLIPT_DB_PATH = /tmp/db","title":"Using Environment Variables"},{"location":"development/","text":"Development The following are instructions for setting up your machine for Flipt development. Requirements Before starting, make sure you have the following installed: GCC Compiler SQLite Go 1.10+ Protoc Compiler Setup Create the directory to clone into: mkdir -p $GOPATH/src/github.com/markphelps Clone this repo: git clone https://github.com/markphelps/flipt $GOPATH/src/github.com/markphelps Run make setup to download dependencies Run make test to execute the test suite Run make dev to build and run in development mode Run make help to see a full list of possible make commands Vagrant You can also easily get started with a development environment running in a VM using Vagrant and Virtual Box . Once you have Vagrant and Virtual Box installed you can change into either the build/ubuntu or build/centos directories and run vagrant up . This will provision a VM that installs the necessary dev dependencies and runs the Flipt test suite. Once the provisioning process is complete, run: $ vagrant ssh $ cd $GOPATH /src/github.com/markphelps/flipt $ make dev This will run Flipt in development mode inside your VM. Configuration Configuration for running when developing Flipt can be found at ./config/local.yml . To run Flipt with this configuration, run: make dev Changes Changing certain types of files such as the protobuf, ui or documentation files require re-building before they will be picked up in new versions of the binary. Updating .proto Files After changing flipt.proto , you'll need to run make proto . This will regenerate the following files: flipt.pb.go flipt.pb.gw.go Updating assets Running make generate will regenerate the embedded assets (ui, api documentation) so that the next time make dev is run they will be included. UI components The UI is built using Yarn and webpack and is also statically compiled into the Flipt binary. The ui/README.md has more information on how to build the UI and also how to run it locally during development.","title":"Development"},{"location":"development/#development","text":"The following are instructions for setting up your machine for Flipt development.","title":"Development"},{"location":"development/#requirements","text":"Before starting, make sure you have the following installed: GCC Compiler SQLite Go 1.10+ Protoc Compiler","title":"Requirements"},{"location":"development/#setup","text":"Create the directory to clone into: mkdir -p $GOPATH/src/github.com/markphelps Clone this repo: git clone https://github.com/markphelps/flipt $GOPATH/src/github.com/markphelps Run make setup to download dependencies Run make test to execute the test suite Run make dev to build and run in development mode Run make help to see a full list of possible make commands","title":"Setup"},{"location":"development/#vagrant","text":"You can also easily get started with a development environment running in a VM using Vagrant and Virtual Box . Once you have Vagrant and Virtual Box installed you can change into either the build/ubuntu or build/centos directories and run vagrant up . This will provision a VM that installs the necessary dev dependencies and runs the Flipt test suite. Once the provisioning process is complete, run: $ vagrant ssh $ cd $GOPATH /src/github.com/markphelps/flipt $ make dev This will run Flipt in development mode inside your VM.","title":"Vagrant"},{"location":"development/#configuration","text":"Configuration for running when developing Flipt can be found at ./config/local.yml . To run Flipt with this configuration, run: make dev","title":"Configuration"},{"location":"development/#changes","text":"Changing certain types of files such as the protobuf, ui or documentation files require re-building before they will be picked up in new versions of the binary.","title":"Changes"},{"location":"development/#updating-proto-files","text":"After changing flipt.proto , you'll need to run make proto . This will regenerate the following files: flipt.pb.go flipt.pb.gw.go","title":"Updating .proto Files"},{"location":"development/#updating-assets","text":"Running make generate will regenerate the embedded assets (ui, api documentation) so that the next time make dev is run they will be included.","title":"Updating assets"},{"location":"development/#ui-components","text":"The UI is built using Yarn and webpack and is also statically compiled into the Flipt binary. The ui/README.md has more information on how to build the UI and also how to run it locally during development.","title":"UI components"},{"location":"getting_started/","text":"Getting Started This document describes how to get started with the Flipt UI. Once you have your application integrated with the Flipt backend, it's time to create some flags to evaluate. This documentation will walk you through creating your first flag, segment, set of rules and finally using the debug console to evaluate everything. For more information on any of the concepts described here, please see the Concepts documentation. Setup Before getting started, make sure the Flipt server is up and running on your host on your chosen ports. See Installation for more. In this example we'll use the default location of http://localhost:8080 . Creating a Flag and Variants Now we'll create a flag and variants that we will use to evaluate against. Create a Flag A flag is the basic entity in Flipt. Flags can represent features in your applications that you want to enable/disable for your users. To create a flag: Open the UI at http://localhost:8080 . Click New Flag . Populate the details of the flag as shown. Click Enabled so the flag will be enabled once created. Click Create . You should see the message Flag created! . Create Variants Variants allow you to return different values for your flags based on rules that you define. To create a variant: On the Flag Details page for the new flag you created, click New Variant . Populate the details of the variant as shown. Click Add Variant . Create one more variant populating the information as you wish. You should see the message Variant added! . Click Flags in the navigation menu and you should now see your newly created flag in the list. Creating a Segment and Constraints Next we'll create a segment with a constraint that will be used to determine the reach of your flag. Create a Segment Segments are used to split your userbase into subsets. To create a segment: From the main page click Segments . Click New Segment . Populate the details of the segment as shown. Click Create . You should see the message Segment created! . Create a Constraint Constraints determine which entities are members of which segments. To create a constraint: On the Segment Details page for the new segment you created, click New Constraint . Populate the details of the constraint as shown. Click Add Constraint . You should see the message Constraint added! . Click Segments in the navigation menu and you should now see your newly created segment in the list. Creating a Rule and Distributions Finally we'll create a rule and set of distributions for your flag and variants. Rules and distributions allow you to define which variant gets returned when you evaluate a specific flag that falls into a given segment. To create a rule and distribution: Go back to the flag you created at the beginning. Click Targeting . Click New Rule . Under Segment: choose the segment you created earlier. Under Then serve: choose A Percentage Rollout . You should see your two variants that you created earlier, with a percentage of 50% each next to them. Click Add Rule . You should see the message Rule added! . You just created your first rule and distribution. A distribution is a way of assigning a percentage for which entities evaluated get a specific variant. The higher the percentage assigned, the more likely it is that any entity will get that specific variant. Note You could just as easily have picked a single variant instead of A Percentage Rollout when setting up your rule. This would effectively mean you have a single distribution, a variant with 100% chance of being returned. Evaluating with the Debug Console After creating the above flag, segment and targeting rule, you're now ready to test how this would work in your application. Fortunately the Flipt UI contains a Debug Console to allow you to experiment with different evaluation requests to see how they would be evaluated. The main ideas behind how evaluation works is described in more detail in the Concepts documentation. To test evaluation: Navigate to the Targeting section for your flag that you created above. Scroll down to the Debug Console section and click into the left pane where you will see a JSON payload. This represents the body of the request that will be evaluated. Notice the flagKey matches the key field of your flag. Notice that entityId is prepopulated with a random UUID. This represents the ID that you would use to uniquely identify entities (ex: users) that you want to test against your flags. Note that the context object is prepopulated as well. This corresponds to the properties that will be evaluated to determine if your request matches any constraints of your segments. Update the context object as shown. Click Debug . Note the Response pane to the right has been populated with the evaluation response from the server, informing you that this request would match your segment that you created earlier, and return one of the variants defined. Experiment with different values for the context and entityId fields. Tip You can click Reset to populate a new example request in the Request pane. This will also generate a fresh UUID for the entityId field. That's it! You're now ready to integrate Flipt into your application and start defining your own flags and segments that will enable you to seamlessly rollout new features to your users while reducing risk.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This document describes how to get started with the Flipt UI. Once you have your application integrated with the Flipt backend, it's time to create some flags to evaluate. This documentation will walk you through creating your first flag, segment, set of rules and finally using the debug console to evaluate everything. For more information on any of the concepts described here, please see the Concepts documentation.","title":"Getting Started"},{"location":"getting_started/#setup","text":"Before getting started, make sure the Flipt server is up and running on your host on your chosen ports. See Installation for more. In this example we'll use the default location of http://localhost:8080 .","title":"Setup"},{"location":"getting_started/#creating-a-flag-and-variants","text":"Now we'll create a flag and variants that we will use to evaluate against.","title":"Creating a Flag and Variants"},{"location":"getting_started/#create-a-flag","text":"A flag is the basic entity in Flipt. Flags can represent features in your applications that you want to enable/disable for your users. To create a flag: Open the UI at http://localhost:8080 . Click New Flag . Populate the details of the flag as shown. Click Enabled so the flag will be enabled once created. Click Create . You should see the message Flag created! .","title":"Create a Flag"},{"location":"getting_started/#create-variants","text":"Variants allow you to return different values for your flags based on rules that you define. To create a variant: On the Flag Details page for the new flag you created, click New Variant . Populate the details of the variant as shown. Click Add Variant . Create one more variant populating the information as you wish. You should see the message Variant added! . Click Flags in the navigation menu and you should now see your newly created flag in the list.","title":"Create Variants"},{"location":"getting_started/#creating-a-segment-and-constraints","text":"Next we'll create a segment with a constraint that will be used to determine the reach of your flag.","title":"Creating a Segment and Constraints"},{"location":"getting_started/#create-a-segment","text":"Segments are used to split your userbase into subsets. To create a segment: From the main page click Segments . Click New Segment . Populate the details of the segment as shown. Click Create . You should see the message Segment created! .","title":"Create a Segment"},{"location":"getting_started/#create-a-constraint","text":"Constraints determine which entities are members of which segments. To create a constraint: On the Segment Details page for the new segment you created, click New Constraint . Populate the details of the constraint as shown. Click Add Constraint . You should see the message Constraint added! . Click Segments in the navigation menu and you should now see your newly created segment in the list.","title":"Create a Constraint"},{"location":"getting_started/#creating-a-rule-and-distributions","text":"Finally we'll create a rule and set of distributions for your flag and variants. Rules and distributions allow you to define which variant gets returned when you evaluate a specific flag that falls into a given segment. To create a rule and distribution: Go back to the flag you created at the beginning. Click Targeting . Click New Rule . Under Segment: choose the segment you created earlier. Under Then serve: choose A Percentage Rollout . You should see your two variants that you created earlier, with a percentage of 50% each next to them. Click Add Rule . You should see the message Rule added! . You just created your first rule and distribution. A distribution is a way of assigning a percentage for which entities evaluated get a specific variant. The higher the percentage assigned, the more likely it is that any entity will get that specific variant. Note You could just as easily have picked a single variant instead of A Percentage Rollout when setting up your rule. This would effectively mean you have a single distribution, a variant with 100% chance of being returned.","title":"Creating a Rule and Distributions"},{"location":"getting_started/#evaluating-with-the-debug-console","text":"After creating the above flag, segment and targeting rule, you're now ready to test how this would work in your application. Fortunately the Flipt UI contains a Debug Console to allow you to experiment with different evaluation requests to see how they would be evaluated. The main ideas behind how evaluation works is described in more detail in the Concepts documentation. To test evaluation: Navigate to the Targeting section for your flag that you created above. Scroll down to the Debug Console section and click into the left pane where you will see a JSON payload. This represents the body of the request that will be evaluated. Notice the flagKey matches the key field of your flag. Notice that entityId is prepopulated with a random UUID. This represents the ID that you would use to uniquely identify entities (ex: users) that you want to test against your flags. Note that the context object is prepopulated as well. This corresponds to the properties that will be evaluated to determine if your request matches any constraints of your segments. Update the context object as shown. Click Debug . Note the Response pane to the right has been populated with the evaluation response from the server, informing you that this request would match your segment that you created earlier, and return one of the variants defined. Experiment with different values for the context and entityId fields. Tip You can click Reset to populate a new example request in the Request pane. This will also generate a fresh UUID for the entityId field. That's it! You're now ready to integrate Flipt into your application and start defining your own flags and segments that will enable you to seamlessly rollout new features to your users while reducing risk.","title":"Evaluating with the Debug Console"},{"location":"installation/","text":"Installation Docker The simplest way to run Flipt is via Docker. This streamlines the installation and configuration by using a reliable runtime. Prerequisites Docker installation is required on the host, see the official installation docs . Note Using a native Docker install instead of Docker Toolbox is recommended in order to use persisted volumes. Run the image docker run -d \\ -p 8080 :8080 \\ -p 9000 :9000 \\ -v $HOME /flipt:/var/opt/flipt \\ markphelps/flipt:latest This will download the image and start a Flipt container and publish ports needed to access the UI and backend server. All persistent Flipt data will be stored in $HOME/flipt . Note $HOME/flipt is just used as an example, you can use any directory you would like on the host. The Flipt container uses host mounted volumes to persist data: Host location Container location Purpose $HOME/flipt /var/opt/flipt For storing application data This allows data to persist between Docker container restarts. Warning If you don't use mounted volumes to persist your data, your data will be lost when the container exits! After starting the container you can visit http://0.0.0.0:8080 to view the application. Linux Packages Flipt RPM/DEB binary packages coming soon! Download from GitHub You can always download the latest release archive for your architecture from the Releases section on GitHub. This archive contains the Flipt binary, configuration, database migrations, README, LICENSE and CHANGELOG files. Copy the binary, config file and migrations to an accessible location on your host. Note You will need to update the config file: default.yml if your migrations and database locations differ from the standard locations. Run the Flipt binary with: ./flipt --config PATH_TO_YOUR_CONFIG See the Configuration section for more details.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#docker","text":"The simplest way to run Flipt is via Docker. This streamlines the installation and configuration by using a reliable runtime.","title":"Docker"},{"location":"installation/#prerequisites","text":"Docker installation is required on the host, see the official installation docs . Note Using a native Docker install instead of Docker Toolbox is recommended in order to use persisted volumes.","title":"Prerequisites"},{"location":"installation/#run-the-image","text":"docker run -d \\ -p 8080 :8080 \\ -p 9000 :9000 \\ -v $HOME /flipt:/var/opt/flipt \\ markphelps/flipt:latest This will download the image and start a Flipt container and publish ports needed to access the UI and backend server. All persistent Flipt data will be stored in $HOME/flipt . Note $HOME/flipt is just used as an example, you can use any directory you would like on the host. The Flipt container uses host mounted volumes to persist data: Host location Container location Purpose $HOME/flipt /var/opt/flipt For storing application data This allows data to persist between Docker container restarts. Warning If you don't use mounted volumes to persist your data, your data will be lost when the container exits! After starting the container you can visit http://0.0.0.0:8080 to view the application.","title":"Run the image"},{"location":"installation/#linux-packages","text":"Flipt RPM/DEB binary packages coming soon!","title":"Linux Packages"},{"location":"installation/#download-from-github","text":"You can always download the latest release archive for your architecture from the Releases section on GitHub. This archive contains the Flipt binary, configuration, database migrations, README, LICENSE and CHANGELOG files. Copy the binary, config file and migrations to an accessible location on your host. Note You will need to update the config file: default.yml if your migrations and database locations differ from the standard locations. Run the Flipt binary with: ./flipt --config PATH_TO_YOUR_CONFIG See the Configuration section for more details.","title":"Download from GitHub"},{"location":"integration/","text":"Integration This document describes how to integrate Flipt in your existing applications. To learn how to install and run Flipt, see the Installation documentation. Once you have the Flipt server up and running within your infrastructure, the next step is to integrate the Flipt client(s) with your applications that you would like to be able to use with Flipt. There are two ways to communicate with the Flipt server: Flipt Native GRPC client(s) Flipt REST API Flipt Native GRPC Client Since Flipt is a GRPC enabled application (see: Architecture ), to communicate with the Flipt server, you can use a generated GRPC client for your language of choice. This means that your application can use the Flipt GRPC client if it is written in one of the many languages that GRPC supports, including: C++ Java Python Go Ruby C# Node.js Android Java Objective-C PHP The Flipt GRPC client is the preferred way to integrate your application with Flipt as it is more performant than REST and requires the least amount of configuration. An example Go application exists at https://github.com/markphelps/flipt/example , showing how you would integrate with Flipt using the Go GRPC client. Getting the Flipt GRPC clients Manually Currently, the best way to get the Flipt GRPC client in your language is to generate it yourself using the existing protobuf definition . The GRPC documentation has extensive examples on how to generate GRPC clients in each supported language. Note GRPC generates both client implementation and the server interfaces. To use Flipt you only need the GRPC client implementation and can ignore the server code as this is implemented by Flipt itself. Download Flipt GRPC clients are currently not available for download directly, but this work is in progress. Please check back soon. Flipt REST API Flipt also comes equipped with a fully functional REST API. In fact, the Flipt UI is completely backed by this same API. This means that anything that can be done in the Flipt UI can also be done via the REST API. The Flipt REST API can also be used with any language that can make HTTP requests. This means that you don't need to use one of the above GRPC clients in order to integrate your application with Flipt. The latest version of the REST API is fully documented using OpenAPI v2 (formerly Swagger) specification available here . Each Flipt server instance also hosts it's own REST API documentation. This documentation is reachable in the Flipt UI by clicking the API link in the header navigation. This will load the API documentation which documents valid requests/responses to the Flipt REST API:","title":"Integration"},{"location":"integration/#integration","text":"This document describes how to integrate Flipt in your existing applications. To learn how to install and run Flipt, see the Installation documentation. Once you have the Flipt server up and running within your infrastructure, the next step is to integrate the Flipt client(s) with your applications that you would like to be able to use with Flipt. There are two ways to communicate with the Flipt server: Flipt Native GRPC client(s) Flipt REST API","title":"Integration"},{"location":"integration/#flipt-native-grpc-client","text":"Since Flipt is a GRPC enabled application (see: Architecture ), to communicate with the Flipt server, you can use a generated GRPC client for your language of choice. This means that your application can use the Flipt GRPC client if it is written in one of the many languages that GRPC supports, including: C++ Java Python Go Ruby C# Node.js Android Java Objective-C PHP The Flipt GRPC client is the preferred way to integrate your application with Flipt as it is more performant than REST and requires the least amount of configuration. An example Go application exists at https://github.com/markphelps/flipt/example , showing how you would integrate with Flipt using the Go GRPC client.","title":"Flipt Native GRPC Client"},{"location":"integration/#getting-the-flipt-grpc-clients","text":"","title":"Getting the Flipt GRPC clients"},{"location":"integration/#manually","text":"Currently, the best way to get the Flipt GRPC client in your language is to generate it yourself using the existing protobuf definition . The GRPC documentation has extensive examples on how to generate GRPC clients in each supported language. Note GRPC generates both client implementation and the server interfaces. To use Flipt you only need the GRPC client implementation and can ignore the server code as this is implemented by Flipt itself.","title":"Manually"},{"location":"integration/#download","text":"Flipt GRPC clients are currently not available for download directly, but this work is in progress. Please check back soon.","title":"Download"},{"location":"integration/#flipt-rest-api","text":"Flipt also comes equipped with a fully functional REST API. In fact, the Flipt UI is completely backed by this same API. This means that anything that can be done in the Flipt UI can also be done via the REST API. The Flipt REST API can also be used with any language that can make HTTP requests. This means that you don't need to use one of the above GRPC clients in order to integrate your application with Flipt. The latest version of the REST API is fully documented using OpenAPI v2 (formerly Swagger) specification available here . Each Flipt server instance also hosts it's own REST API documentation. This documentation is reachable in the Flipt UI by clicking the API link in the header navigation. This will load the API documentation which documents valid requests/responses to the Flipt REST API:","title":"Flipt REST API"}]}